\documentclass[a4paper,12pt]{book}
% packages
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage{bm}
\usepackage[a4paper]{geometry}
\geometry{margin=1in}
\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{subcaption}
\usepackage{fullpage}
\usepackage{setspace}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{booktabs}
\usepackage{commath}
\usepackage{multirow}
%\usepackage[newfloat]{minted}
\usepackage{csquotes}
\usepackage[hidelinks]{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\SetKwProg{Function}{Function}{:}{end}
\SetKwBlock{Main}{main()}{end}
\SetKwInOut{KwParam}{Parameters}
\usepackage{etoolbox}
\AtBeginEnvironment{algorithm}{\SetArgSty{textrm} \SetAlgoLined \DontPrintSemicolon \SetNoFillComment}
\usepackage[table,xcdraw]{xcolor}

\begin{document}
	
\begin{titlepage}
	
\frontmatter

\begin{center}
	% Upper part of the page
	\includegraphics[scale=.10]{unipd.png}
	\\
	\vspace{1cm}
	\textsc{\LARGE University of Padova} \\
	\vspace{1cm}
	\textsc{\Large Information Engineering Department (DEI)} \\
	\vspace{1cm} 
	\textsc{\Large Master's Degree in Computer Engineering} \\ %\hspace{0.8cm}
	% Title
	\vspace{0.8cm}
	\Huge \doublespacing \bfseries \begin{spacing}{1}{Implementation of the ZI-Round heuristic for Mixed Integer Programming}\end{spacing}
	\hfill
	\Large \bfseries \begin{spacing}{1}{Master Thesis}\end{spacing}
	\hfill
	\vspace{0.5cm}
	% Author and supervisor
	\begin{flushleft} \large
		\emph{Supervisor:} \\
		Prof. Domenico Salvagnin
	\end{flushleft}
	\vfill
	\begin{flushright} \large
		\emph{Student:}\\
		Ivan Viviani (1206151)
	\end{flushright}
	\hfill
	\vfill
	% Bottom of the page
	{\small Academic Year 2019/2020} 
\end{center}
\end{titlepage}
	
\tableofcontents

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RE,LO]{\rightmark}
\fancyfoot[CE,CO]{\thepage}
\renewcommand{\headrulewidth}{0pt}

\mainmatter

%* \chapter{Definitions}

\chapter{ZI-Round MIP rounding heuristic} \label{ch:ziround}

ZI-round is a MIP rounding heuristic introduced by C. Wallace \cite{wallace2010} as an extension of the Simple Rounding heuristic, which was introduced in the non-commercial solver SCIP \cite{scip}.
From a primal feasible solution of the MIP continuous relaxation, both heuristics aim at rounding all the fractional integer variables, in order to obtain a feasible solution of the MIP. Simple Rounding is a pure integer rounding heuristic because it only rounds fractional integer variables, while ZI-Round also takes other factors into account, such as the singletons of the constraints, where a singleton is defined as a continuous variable that appears in only one constraint. \par

\section{Simple Rounding}
As its name suggests, Simple Rounding is the most straightforward approach: it scans the integer variables once and only rounds those that can be trivially rounded, keeping all the constraints satisfied without affecting other factors such as the constraint slacks and singletons.
Recall that a variable can be trivially rounded up or down only if any up-shift or down-shift within its bounds keeps all the constraints satisfied. \par

For example, consider a "less than" constraint in which the fractional integer variable $x_j$ appears with a positive coefficient $a_{ij} > 0$. Since this constraint is satisfied as long as its row activity is less than its right hand side, $x_j$ could only be rounded down, causing the row activity to decrease without affecting the constraint satisfiability. For the same constraint, if the variable $x_j$ appears with a negative coefficient $a_{ij} < 0$ instead, $x_j$ could only be rounded up, with the same outcome.
Now consider a "greater than" constraint in which the fractional integer variable $x_j$ appears with a negative coefficient $a_{ij} < 0$. Since this constraint is satisfied as long as its row activity is greater than its right hand side, $x_j$ could only be rounded down, causing the row activity to increase without affecting the constraint satisfiability. For the same constraint, if the variable $x_j$ appears with a positive coefficient $a_{ij} > 0$, $x_j$ could onyl be rounded up, with the same outcome.
Finally, consider an equality constraint in which the fractional integer variable $x_j$ appears. Since this constraint is satisfied as long as its row activity is equal to its right hand side, $x_j$ cannot be rounded in either direction without affecting other factors. \par

The previous examples describe the concept of trivial roundability for a fractional integer variable $x_j$ in a single constraint. But in order for a variable to be trivially roundable in a given direction, it must be roundable in all the constraints that comprise it, without affecting factors other than the variable itself. 
Note that it suffices that a variable appears in an equality constraint for it not to be trivially roundable in either direction, i.e. Simple Rounding cannot round variables that appear in at least one equality constraint.
A formal characterization of trivial roundability for a variable $x_j$ in the case of rounding up follows.
A variable $x_j$ can be trivially rounded up if and only if all the following conditions apply:
\begin{itemize}
	\item In all the "less than" constraints containing $x_j$, the variable appears with a negative coefficient $a_{ij} < 0$;
	\item In all the "greater than" constraints containing $x_j$, the variable appears with a positive coefficient $a_{ij} > 0$;
	\item All the equality constraints do not contain $x_j$.
\end{itemize}
A variable $x_j$ can be trivially rounded down if and only if all the following conditions apply:
\begin{itemize}
	\item In all the "less than" constraints containing $x_j$, the variable appears with a positive coefficient $a_{ij} > 0$;
	\item In all the "greater than" constraints containing $x_j$, the variable appears with a negative coefficient $a_{ij} < 0$;
	\item All the equality constraints do not contain $x_j$.
\end{itemize}
\par

The simplicity of Simple Rounding comes from its adherence to trivial roundability, which allows it to round variables without worrying about any other factors. As noted previously, this simplicity comes at the cost of effectiveness, since equality constraints make all the contained variables un-roundable. This major weakness of Simple Rounding can be overcome by taking other factors into account, as done by C. Wallace \cite{wallace2010} in the case of the ZI-Round heuristic. Also note that since a variable is or is not trivially roundable independently of other variables, and each trivial rounding causes the row activity of the constraints to decrease in the case of "less than" constraints and to increase in the case of "greater than" constraints, Simple Rounding only needs to scan the variables once.

\section{ZI-Round}
The ZI-Round heuristic greatly extends Simple Rounding by allowing non-trivial roundings to be made and cleverly using the singletons of each constraint (if any) as an additional slack. Non-trivial roundings are those in directions that do not ensure constraint satisfiability, i.e. some constraints could be violated due to the rounding. The use of singletons is essential for equality constraints, since it gives them a slack to rely on for rounding their contained variables. \par

An optional extension that can be easily implemented in ZI-Round is to allow the unit shifting of non-fractional integer variables to improve the objective value, while still maintaining non-fractionality. This extension can be seen as a sort of local search heuristic \cite{linker1973} or intensification strategy, analogous to $k$-OPT improvement for TSPs when $k = 1$, but different since imrovements are made before an integral solution is found \cite{wallace2010}. \par

In the context of ZI-Round, the attempt to round all the fractional integer variables of the solution is carried out as an optimization problem where the objective function to minimize to zero is the solution fractionality, only relative to the integer variables of the original MIP (binary variables included). The fractionality of a single variable $x_j$ can be expressed as:
\begin{equation}
	f(x_j) = \text{min}\{x_j - \lfloor x_j \rfloor, \lceil x_j \rceil - x_j\}
\end{equation}
The fractionality of the solution, only relative to integer variables, is then given by:
\begin{equation}\label{eq:zi}
	f(x) = \sum_{j \in I \cup B}f(x_j)
\end{equation}
In accordance with the original work by C. Wallace \cite{wallace2010} and the name of the heuristic, in the rest of this thesis the solution fractionality is referred to as $ZI(x)$. \par 

While Simple Rounding scans the variables only once, since each variable can be trivially roundable independently of the others, ZI-Round needs to scan them multiple times: non-trivial roundings, and unit shiftings if the improvement extension is implemented, can change the row activities in both directions, causing the constraint (and singleton) slacks to possibly influence the roundability of other variables. Programmatically, this translates to having an outer loop that allows to perform multiple rounds and an inner loop that scans the integer variables, representing a single round. The pseudocode of the ZI-Round heuristic is presented in Algorithm~\ref{alg:ziround}. \par 

\SetKwRepeat{Do}{do}{while}
\begin{algorithm}[htp]
	\KwIn{$x$: primal feasible solution of continuous relaxation.}
	
	\Function{\upshape \texttt{ziround}}{
		\BlankLine
		$\Delta^{up}$ $\gets$ $\star$ maximum variable up-shifts $\star$ \;
		$\Delta^{down}$ $\gets$ $\star$ maximum variable down-shifts $\star$ \;
		$CS$ $\gets$ $\star$ constraint slacks $\star$ \;
		$SS$ $\gets$ $\star$ singleton slacks $\star$ \;
		$c$ $\gets$ $\star$ objective function coefficients $\star$ \;
		$c^Tx$ $\gets$ $\star$ objective value $\star$ \;
		$f(x_j)$ $\gets$ $\star$ fractionality of variable $x_j$ $\forall j$ $\star$ \;
		$ZI(x)$ $\gets$ $\star$ solution fractionality ($= \sum_{j \in I \cup B}f(x_j)$) $\star$ \;
		\BlankLine
		\Do{$\star$ variable roundings found $\star$}{
			\BlankLine
			\ForEach{$\star$ integer/binary variable $x_j$ $\star$}{
				\BlankLine
				\uIf{$\star$ $x_j$ non-fractional $\star$} {
					\BlankLine
					$\star$ compute maximum shifts of $x_j$ (threshold $\varepsilon = 1$) $\star$ \;
					\BlankLine
					\If{$(c_j \geq 0 \wedge \Delta_{j}^{down} = 1) \vee (c_j \leq 0 \wedge \Delta_{j}^{up} = 1)$}{
						\BlankLine
						$\star$ round (shift) $x_j$ to improve $c^Tx$ $\star$ \;
						$\star$ update slacks $CS$ and $SS$ $\star$ \;
						$\star$ update $c^Tx$ $\star$ \;
						\BlankLine
					}
					\BlankLine
				}
				\ElseIf{$\star$ $x_j$ fractional $\star$}{
					\BlankLine
					$\star$ compute maximum shifts of $x_j$ (threshold $\varepsilon = 10^{-5}$) $\star$ \;
					\BlankLine
					\uIf{$\star$ both shifts improve $ZI(x)$ of the same amount $\star$}{
						\BlankLine
						$\star$ round $x_j$ to improve $c^Tx$ $\star$ \;
						$\star$ update slacks $CS$ and $SS$ $\star$ \;
						$\star$ update $c^Tx$ $\star$ \;
						\BlankLine
					}
					\uElseIf{$\star$ rounding $x_j$ up improves $ZI(x)$ more $\star$}{
						\BlankLine
						$x_j$ $\gets$ $x_j + \Delta_{j}^{up}$ \;
						$\star$ update slacks $CS$ and $SS$ $\star$ \;
						$\star$ update $c^Tx$ $\star$ \;
						\BlankLine
					}
					\ElseIf{$\star$ rounding $x_j$ down improves $ZI(x)$ more $\star$}{
						\BlankLine
						$x_j$ $\gets$ $x_j - \Delta_{j}^{down}$ \;
						$\star$ update slacks $CS$ and $SS$ $\star$ \;
						$\star$ update $c^Tx$ $\star$ \;
						\BlankLine
					}
				}
			}
		}
	}
	\caption{ZI-Round.}
	\label{alg:ziround}
\end{algorithm}

Non-trivial roundings could violate some constraints, therefore we need to determine how much each variable can be shifted in either direction towards its nearest integers, without violating any constraint. This information is denoted by the two arrays $\Delta^{up}, \Delta^{down}$ with index $j$ over the variables of the MIP. So $x_j$ can be shifted to either $x_j + \Delta_{j}^{up}$ or $x_j - \Delta_{j}^{down}$. \par

Whenever a variable is non-trivially rounded, the slacks of the constraints in which it is involved change and affect the possible shifts of other variables. So we need to keep track of the current values of the constraint slacks, denoted by the array $CS$ with index $i$ over the constraints of the MIP.
ZI-Round also accounts for the singletons of each constraint, which generate a further constribution to the overall slack, referred to as singletons slack and denoted by the array $SS$ with index $i$ over the constraints of the MIP. \par 

The singleton slack of a constraint is defined as the contribution to the row activity given by the singletons. It can be seen as a single variable comprising the contributions of the singletons. 
Since the singletons are continuous variables that appear in only one constraint, they can be shifted freely without affecting other constraints, thus their contribution to the row activity can be manipulated in order to keep the constraint satisfied while rounding fractional integer variables. For example, consider the constraint $x_1 + x_2 + x_3 = 10$ where $x_1 = 3$, $x_2 = 4.5$, $x_3 = 2.5$, $x_2$ is the fractional integer variable that has to be rounded and $x_3$ is a singleton of the constraint. The only way to round $x_2$ is to use the available row activity contribution of $2.5$ given by $x_3$ to compensate for the shift: e.g. if $x_2$ is rounded up to $5$ then $x_3$ needs to be shifted down to $2$, and the constraint remains satisfied. \par 

Before any rounding can be performed, we need to determine the maximum up-shifts and down-shifts of the integer variables. To maintain primal feasibility, a variable shift must keep all the slacks of "less than" constraints non-negative, all the slacks of "greater than" constraints non-positive, and all the slacks of equality constraints equal to zero, intended as constraint slacks. \par

Consider an integer variable $x_j$ for which we want to determine $\Delta_{j}^{up}$ and $\Delta_{j}^{down}$.
For a "less than" constraint of index $i$ where $x_j$ has a positive coefficient $a_{ij} > 0$, the maximum up-shift of $x_j$ that can be compensated by the overall slack is given by $(CS_i + \Delta_{max}^{down}(SS_i)) / a_{ij}$, where $\Delta_{max}^{down}(SS_i))$ is the maximum down-shift of the singletons slack $SS_i$. Note that for $a_{ij} < 0$ the variable $x_j$ is trivially up-roundable in the constraint.
For a "less than" constraint of index $i$ where $x_j$ has a negative coefficient $a_{ij} < 0$, the maximum down-shift of $x_j$ that can be compensated by the overall slack is given by the same expression with a minus sign to keep the final value unsigned, i.e. $-(CS_i + \Delta_{max}^{down}(SS_i)) / a_{ij}$. Note that for $a_{ij} > 0$ the variable $x_j$ is trivially down-roundable in the constraint. In both the previous cases we consider the maximum down-shift of $SS_i$ because for "less than" constraints it is the one that increases the absolute value of the numerator, thus the final value, since $CS_i \geq 0$. \\
For a "greater than" constraint of index $i$ where $x_j$ has a negative coefficient $a_{ij} < 0$, the maximum up-shift of $x_j$ that can be compensated by the overall slack is given by $(CS_i - \Delta_{max}^{up}(SS_i)) / a_{ij}$, where $\Delta_{max}^{up}(SS_i))$ is the maximum up-shift of the singletons slack $SS_i$. Note that for $a_{ij} > 0$ the variable $x_j$ is trivially up-roundable in the constraint.
For a "greater than" constraint  of index $i$ where $x_j$ has a positive coefficient $a_{ij} > 0$, the maximum down-shift of $x_j$ that can be compensated by the overall slack is given by the same expression with a minus sign to keep the final value unsigned, i.e. $-(CS_i - \Delta_{max}^{up}(SS_i)) / a_{ij}$. Note that for $a_{ij} < 0$ the variable $x_j$ is trivially down-roundable in the constraint. In both the previous cases we consider the maximum up-shift of $SS_i$ because for "greater than" constraints it is the one that increases the absolute value of the numerator, thus the final value, since $CS_i \leq 0$. \\
Equality constraints can exclusively rely on their singletons slack, which unlike the constraint slack can be positive or negative. So an equality constraint can be viewed as a "less than" constraint when its singletons slack is positive and as a "greater than" constraint when its singletons slack is negative. For an equality constraint of index $i$ where $x_j$ has a positive coefficient $a_{ij} > 0$, the maximum up-shift of $x_j$ that can be compensated by the singletons slack is given by $\Delta_{max}^{down}(SS_i) / a_{ij}$, while the maximum down-shift is given by $\Delta_{max}^{up}(SS_i) / a_{ij}$. For an equality constraint of index $i$ where $x_j$ has a negative coefficient $a_{ij} < 0$, the maximum up-shift of $x_j$ that can be compensated by the singletons slack is given by $-\Delta_{max}^{up}(SS_i) / a_{ij}$, while the maximum down-shift is given by $-\Delta_{max}^{down}(SS_i) / a_{ij}$. \par 

All the considerations made so far hold for a single constraint, but in order to keep all the constraints satisfied we need to find the minimum over all the constraints of such maximum quantities. The idea is that each constraint gives two candidates for $\Delta_{j}^{up}$ and $\Delta_{j}^{down}$, respectively. Then the final maximum shifts of $x_j$ are determined as the minimum candidate for each rounding direction. 
Note that the variables also have to stay within their lower and upper bounds, so two additional candidates are given by the quantities $x_j - lb_j$ for $\Delta_{j}^{down}$ and $ub_j - x_j$ for $\Delta_{j}^{up}$, where $lb_j$ and $ub_j$ denote the variable bounds.
A more formal characterization of the maximum up-shift and down-shift of a variable $x_j$ follows. \par

For "less than" constraints, a variable $x_j$ cannot be shifted up more than
\begin{equation}
	\Delta_{j,\leq}^{up} = \min_{i,\leq}\left\{\dfrac{(CS_i + \Delta_{max}^{down}(SS_i))}{a_{ij}} : a_{ij} > 0\right\}
\end{equation}
and it cannot be shifted down more than
\begin{equation}
	\Delta_{j,\leq}^{down} = \min_{i,\leq}\left\{\dfrac{-(CS_i + \Delta_{max}^{down}(SS_i))}{a_{ij}} : a_{ij} < 0\right\}
\end{equation}
For "greater than" constraints, a variable $x_j$ cannot be shifted up more than
\begin{equation}
	\Delta_{j,\geq}^{up} = \min_{i,\geq}\left\{\dfrac{(CS_i - \Delta_{max}^{up}(SS_i))}{a_{ij}} : a_{ij} < 0\right\}
\end{equation}
and it cannot shifted down more than
\begin{equation}
	\Delta_{j,\geq}^{down} = \min_{i,\geq}\left\{\dfrac{-(CS_i - \Delta_{max}^{up}(SS_i))}{a_{ij}} : a_{ij} > 0\right\}
\end{equation}
For equality constraints, a variable $x_j$ cannot be shifted up more than
\begin{equation}
	\Delta_{j,=}^{up} = \min \left\{ \min_{i,=}\left\{\dfrac{\Delta_{max}^{down}(SS_i)}{a_{ij}} : a_{ij} > 0\right\} , \min_{i,=}\left\{\dfrac{-\Delta_{max}^{up}(SS_i)}{a_{ij}} : a_{ij} < 0 \right\} \right\}
\end{equation}
and it cannot be shifted down more than
\begin{equation}
	\Delta_{j,=}^{down} = \min \left\{ \min_{i,=}\left\{\dfrac{\Delta_{max}^{up}(SS_i)}{a_{ij}} : a_{ij} > 0\right\} , \min_{i,=}\left\{\dfrac{-\Delta_{max}^{down}(SS_i)}{a_{ij}} : a_{ij} < 0 \right\} \right\}
\end{equation}

Grouping the three types of constraints together and considering also the additional candidates given by the variable bounds yields the final values of the maximum shifts of $x_j$ that maintain primal feasibility:
\begin{equation}
	\Delta_{j}^{up} = \text{min} \{\Delta_{j,\leq}^{up} \,,\, \Delta_{j,\geq}^{up} \,,\, \Delta_{j,=}^{up} \,,\, ub_j - x_j\}
\end{equation}
\begin{equation}
	\Delta_{j}^{down} = \text{min} \{\Delta_{j,\leq}^{down} \,,\, \Delta_{j,\geq}^{down} \,,\, \Delta_{j,=}^{down} \,,\, x_j - lb_j\}
\end{equation}

One detail that speeds up the ZI-Round heuristic, as recommended by C. Wallace \cite{wallace2010}, is to stop calculating $\Delta_{j}^{up}$ and $\Delta_{j}^{down}$ once they both fall below a pre-defined small positive threshold, denoted by $\varepsilon$. In practice we use the same value chosen by C. Wallace, i.e. $\varepsilon = 10^{-5}$. If the ZI-Round extension that shifts non-fractional integer variables is implemented, as done in this thesis, for determining the possible shifts in that case it suffices to set the threshold $\varepsilon = 1$, because $x_j$ must be shifted by $1$ to maintain the current solution fractionality $ZI(x)$. \par 

As presented in the inner loop of Algorithm~\ref{alg:ziround}, if the current variable $x_j$ is non-fractional then the improvement extension is applied, whereas if $x_j$ is fractional then it enters the core of the ZI-Round heuristic. As initially mentioned, ZI-Round aims at minimizing the solution fractionality $ZI(x)$ expressed by Equation~\ref{eq:zi}, therefore $x_j$ should be rounded in the direction that improves $ZI(x)$, with ties resolved in favor of the direction that improves the objective value $c^Tx$. The pseudocode of the function that, given both the maximum shifts of a variable $x_j$, shifts it in the direction that improves $c^Tx$ is presented in Algorithm~\ref{alg:roundxjbestobj}. Particular care must be taken when non-fractional integer variables have to be shifted by this function: it is important to ensure that $ZI(x)$ is maintained by checking that the shift applied has a value of $1$. \par

\begin{algorithm}[ht]
	\KwIn{$j$: variable index; $\Delta_{j}^{up}$: maximum variable up-shift; $\Delta_{j}^{down}$: maximum variable down-shift.}

	\Function{\upshape \texttt{round\_xj\_bestobj}}{
		\BlankLine
		$CS$ $\gets$ $\star$ constraint slacks $\star$ \;
		$SS$ $\gets$ $\star$ singleton slacks $\star$ \;
		$c$ $\gets$ $\star$ objective function coefficients $\star$ \;
		$c^Tx$ $\gets$ $\star$ objective value $\star$ \; 
		\BlankLine
		\uIf{$\star$ rounding $x_j$ up improves $c^Tx$ more $\star$}{
			\BlankLine
			$x_j$ $\gets$ $x_j + \Delta_{j}^{up}$ \;
			$\star$ update slacks $CS$ and $SS$ $\star$ \;
			$\star$ update $c^Tx$ $\star$ \;
			\BlankLine
		}
		\uElseIf{$\star$ rounding $x_j$ down improves $c^Tx$ more $\star$}{
			\BlankLine
			$x_j$ $\gets$ $x_j - \Delta_{j}^{down}$ \;
			$\star$ update slacks $CS$ and $SS$ $\star$ \;
			$\star$ update $c^Tx$ $\star$ \;
			\BlankLine
		}
		\ElseIf{$\star$ both shifts improve $c^Tx$ of the same amount ($0$ included) $\star$}{
			\BlankLine
			$\star$ round $x_j$ arbitrarily $\star$ \;
			$\star$ update slacks $CS$ and $SS$ $\star$ \;
			$\star$ update $c^Tx$ $\star$ \;
			\BlankLine
		}
	}
	\caption{Round $x_j$ to improve objective.}
	\label{alg:roundxjbestobj}
\end{algorithm}

After any rounding has been made, we need to update the constraint slacks $CS$ and possibly the singletons slacks $SS$. The pseudocode of the function that, given the signed shift that was used to round a variable $x_j$, computes the corresponding slack shift for each constraint of index $i$ and distributes it on the constraint slack $CS_i$ and/or the singletons slack $SS_i$ (if any) is presented in Algorithm~\ref{alg:updateslacks}. The function scans the constraints containing the integer variable $x_j$ and updates the slacks. For each constraint of index $i$ it first computes the signed overall slack shift corresponding to the signed variable shift $\Delta_{j}$, given by:
\begin{equation}
	\Delta_{i}^{slack} = a_{ij} \Delta_{j}
\end{equation}
where $a_{ij}$ is the coefficient of $x_j$ in the constraint. Then as much of the overall slack shift as possible is distributed on the constraint slack $CS_i$. If the constraint has any singletons, $CS_i$ could not be able to compensate for all of $\Delta_{i}^{slack}$, so in this case the remaining slack shift $\Delta_{i}^{SS}$ has to be distributed on the singletons slack $SS_i$, thus among the singletons of the constraint. \par

Note that since the singletons of the constraint are actual variables of the MIP, an update of the singletons requires to update the current objective value $c^Tx$. Also, observe that the slacks are updated only after a successful rounding or shifting, therefore $\Delta_{i}^{slack}$ can always be distributed correctly. \par

\begin{algorithm}[ht]
	\KwIn{$j$: index of the rounded variable; $\Delta_{j}$: signed variable shift.}
	
	\Function{\upshape \texttt{update\_slacks}}{
		\BlankLine
		$CS$ $\gets$ $\star$ constraint slacks $\star$ \;
		$SS$ $\gets$ $\star$ singleton slacks $\star$ \;
		\BlankLine
		\ForEach{$\star$ constraint containing $x_j$ $\star$}{
			\BlankLine
			$a_{ij}$ $\gets$ $\star$ coefficient of $x_j$ in $i^{th}$ constraint $\star$ \;
			$\Delta_{i}^{slack}$ $\gets$ $\star$ slack shift of the constraint ($= a_{ij} \, \Delta_{j}$) to be distributed $\star$ \;
			\BlankLine
			\uIf{$\star$ constraint sense $\leq$ or $\geq$ $\star$}{
				\BlankLine
				\uIf{$\star$ constraint has singletons $\star$} {
					\BlankLine
					$\star$ update constraint slack $CS_i$ to cover $\Delta_{i}^{slack}$ as much as possible $\star$ \;
					$\Delta_{i}^{SS}$ $\gets$ $\star$ remaining slack shift (covered by the singletons) $\star$ \;
					$SS_i$ $\gets$ $SS_i + \Delta_{i}^{SS}$ \;
					$\star$ update constraint singletons by distributing $\Delta_{i}^{SS}$ (if any) $\star$ \;
					$\star$ update $c^Tx$ if singletons were updated $\star$ \;
					\BlankLine
				}
				\Else{
					\BlankLine
					$\star$ update constraint slack $CS_i$ $\star$ \;
					\BlankLine
				}
				\BlankLine
			}
			\ElseIf{$\star$ constraint sense $=$ $\star$}{
				\BlankLine
				\If{$\star$ constraint has singletons $\star$}{
					\BlankLine
					$\Delta_{i}^{SS}$ $\gets$ $\Delta_{i}^{slack}$ \;
					$SS_i$ $\gets$ $SS_i + \Delta_{i}^{SS}$ \;
					$\star$ update constraint singletons by distributing $\Delta_{i}^{SS}$ $\star$ \;
					$\star$ update $c^Tx$ $\star$ \;
					\BlankLine
				}
			}
		}
	}
	\caption{Update slacks.}
	\label{alg:updateslacks}
\end{algorithm}

On a final note, the observations and experimental results of C. Wallace \cite{wallace2010} show that ZI-Round can round any variable that Simple Rounding can round, while maintaining similar overall running times, but ZI-Round can find more solutions.

\chapter{ZI-Round extensions}
In this thesis the implementation of ZI-Round that takes the singletons into account and employs the extension of improving the objective value by shifting non-fractional integer variables while rounding the fractional ones is referred to as the default version, i.e. the one described in Chapter~\ref{ch:ziround}. \par
In this chapter, some variations and extensions of the ZI-Round heuristic are presented, together with some example charts showing the behavior of the solution cost and fractionality as the inner loop iterations of ZI-Round progress. Note that only one feature at a time is changed from the default ZI-Round implementation: all the features of default ZI-Round are kept, except for the one changed by each extension.
Eventually, a new default version of ZI-Round is proposed. \par 
The charts presented are made by the author of this thesis using the Gnuplot graphing utility \cite{gnuplot}, called directly from the main program through a pipe. The data portrayed by the charts is obtained from the experiments conducted, which are described in detail in Chapter~\ref{ch:compresults}.

\section{Default ZI-Round}
The default version of ZI-Round shifts both fractional and non-fractional integer variables, the latter to improve the objective value.
The two phases of rounding and objective improvement are overlapped, causing the solution cost to vary unsteadily until all the fractional integer variables have been rounded. The rounding phase terminates when the solution fractionality reaches zero and from that point on the objective improvement phase continues until no more improvements are possible.
A visual example of such behavior is shown in Figure~\ref{fig:exzi-default} for the instance \texttt{fast0507}: the two phases coexist until the solution fractionality reaches zero, at which point only the objective value improvement occurs.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{fast0507-default.png}
	\caption{ZI-Round execution for the instance \texttt{fast0507}: default.}
	\label{fig:exzi-default}
\end{figure}

\section{Sorted singletons}
A first simple extension follows from a possible improvement on the order in which the singletons of a given constraint are considered when distributing the singletons slack on them, with the aim of worsening the objective value as little as possible. \par 

In the default implementation of ZI-Round the singletons are considered in their natural order. The proposed improvement consists in sorting the singletons of each constraint in ascending order of their objective function coefficients, so that the first singleton variables to be updated are the ones that affect the objective value the least. \par

We recognize that this greedy approach does not ensure to always affect the objective value in a positive way, since the current possible singleton variations would need to be taken into account at each iteration, and those variations depend on the bounds of the singleton and its coefficient in the constraint. However, this simple extension is tested with the aim of showing whether and in what amount the order in which the singletons are considered influences the end results. The chosen reference instances do not have any singletons in their constraints, hence no example charts are available for this extension.

\section{No objective improvement}
Another extension of ZI-Round worth analyzing is the shift of non-fractional integer variables to improve the objective value as much as possible. Since this extension is part of the default version of ZI-Round, its complementary counterpart is considered, i.e. the absence of it. \par

The rationale behind this non-extension is the following. First, observe that the overall slack of a constraint can be viewed as its capacity to cover the possible shift of one of its variables, and a variable shift can either increase or decrease that capacity. Also, in a way, the constraints of a MIP should generally go against the objective function, otherwise the problem would be unbounded. It follows that shifting non-fractional integer variables to improve the objective value should contribute to the saturation of the shift coverage capacity of the constraints, which could not be able to allow all the fractional integer variables to be rounded. \par

This non-extension that avoids shifting non-fractional integer variables is tested with the aim of showing whether and in what amount the attempt to improve the objective value while rounding all the integer variables influences the end results, especially in terms of quality of the solutions found. \par

Without objective improvement, the rounding phase is free to operate and terminates as soon as the solution fractionality reaches zero, marking the end of the heuristic. A visual example of such behavior is shown in Figure~\ref{fig:exzi-noobjimprove} for the instance \texttt{fast0507}. Note that all the fractional integer variables are rounded after way less iterations with respect to the default version, which shows how the objective improvement phase interferes with the rounding phase, making the rounding process longer.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{fast0507-noshiftnonfrac.png}
	\caption{ZI-Round execution for the instance \texttt{fast0507}: no objective improvement.}
	\label{fig:exzi-noobjimprove}
\end{figure}

\section{Objective improvement after zero fractionality}
The previous non-extension is a rather conservative approach that avoids any objective value imrovement from start to finish. \par 

A very reasonable extension that allows the fractional integer variables to fully rely on the slacks in order to be rounded and the objective value to be improved consists in starting to shift the non-fractional integer variables only after all the fractional ones have been rounded. In other words, this extension would follow the previous one until the fractionality of the solution reaches zero or no more fractional variables can be rounded, and then start improving the objective value by shifting all the integer variables, which would all be non-fractional at that point. \par

This two-phased extension that first concentrates on rounding all the fractional integer variables and only after no more fractional variables can be rounded proceeds to improve the objective value is tested with the aim of showing whether and in what amount separating the rounding phase and the objective improvement phase affects the end results. \par 

Since the two phases are separated, at first all the slacks are exclusively available to the rounding phase, which is prioritized. This separation is reflected in the behavior of the solution cost, which tends to increase while the fractionality approaches zero, at which point the objective improvement phase starts shifting the non-fractional integer variables, causing the objective value to decrease until no more improvements are possible. A visual example of such behavior is shown in Figure~\ref{fig:exzi-objimproveafter0frac} for the instance \texttt{fast0507}. The rounding phase is the same as in Figure~\ref{fig:exzi-noobjimprove}, with the solution fractionality of the instance reaching zero at iteration $275$, at which point the objective improvement phase starts operating until the end of the heuristic.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{fast0507-shiftnfafter0frac.png}
	\caption{ZI-Round execution for the instance \texttt{fast0507}: objective improvement after zero fractionality.}
	\label{fig:exzi-objimproveafter0frac}
\end{figure}

\section{Worst-objective fractionality tie-breaks}
The final extension proposed follows from the observation that any attempt at improving the objective value generally goes against the capacity of the constraints to compensate for the shifts of the variables they contain. \par 

As reported in Algorithm~\ref{alg:ziround}, the default behavior of ZI-Round when fractionality tie-breaks occur during the rounding process of a fractional integer variable is to prefer the rounding direction that improves the objective value the most, or worsens it the least. This proposed extension, instead, in such cases would choose to round the variable in the direction that worsens the objective value the most, or improves it the least. This behavior would in fact favor the constraints, thus the possibility of rounding more fractional integer variables. \par

Note that the shifting of non-fractional integer variables of the default ZI-Round implementation is maintained. This mixed extension that favors both the objective function and the constraints is tested with the aim of showing whether and in what amount favoring the constraints when either direction can be chosen while rounding a fractional integer variable affects the end results. \par 

Since the direction that worsens the objective value is chosen whenever a tie on the fractionality improvement given by a possible shift occurs, in such cases more power is given to the rounding phase. On the other hand, the objective improvement phase still operates concurrently throughout the execution of the heuristic. A visual example of such behavior is shown in Figure~\ref{fig:exzi-fractieworstobj} for the instance \texttt{fast0507}: as expected, it is similar to the one obtained by the default version of ZI-Round, since the two phases still interfere with each other from the start.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{fast0507-fractieworstobj.png}
	\caption{ZI-Round execution for the instance \texttt{fast0507}: worst-objective fractionality tie-breaks.}
	\label{fig:exzi-fractieworstobj}
\end{figure}

\section{Proposed ZI-Round}
From the behaviors of the extensions observed and the experiments conducted, the following version of ZI-Round is proposed as the new default. The proposed ZI-Round heuristic employs the sorting of the singletons of each constraint, the worst-objective fractionality tie-breaks and the objective improvement after the fractionality reaches zero. The experimental results that support this choice are presented in Chapter~\ref{ch:compresults}. \par
The behavior of the solution cost and fractionality for the instance \texttt{fast0507} under the proposed version of ZI-Round is shown in Figure~\ref{fig:exzi-proposed}. Unlike in Figure~\ref{fig:exzi-objimproveafter0frac}, where the final objective value is $221$, in this case a solution with an objective value of $214$ is found.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{fast0507-proposed.png}
	\caption{ZI-Round execution for the instance \texttt{fast0507}: proposed.}
	\label{fig:exzi-proposed}
\end{figure}

\chapter{Computational results} \label{ch:compresults}
%! Scopo degli esperimenti: analizzare la performance di ZI-Round nelle sue varie estensioni/varianti in termini di numero di soluzioni intere trovate e tempo di esecuzione.
The performance of the ZI-Round heuristic is analyzed in the following experiments, in which one extension at a time is changed from the default version. The main measures of interest are the number or percentage of integer solutions found, the quality of those solutions and the execution time of ZI-Round. \par

In Section~\ref{sec:expsetup}, the experimental setup used for the set of experiments on the different versions of ZI-Round is presented. In particular, it comprises the specification of the hardware and software tools used, the description of the test-beds used for the experiments, the specification of the single measures performed on the instances and the aggregate measures computed on the test-beds. Also, a second interesting set of experiments that exploit the shift of dimensional space seen in the presolving process of CPLEX is introduced. \par 

In Section~\ref{sec:expresults} \dots

\section{Experimental setup} \label{sec:expsetup}

\subsection{Hardware and software tools}
%! Strumenti: specifiche PC, software/tools usati
All the experiments are performed on a Dell XPS $15$ $7590$, with an exa-core $4.5$ GHz i$7$-$9750$H processor and $16$ GB of RAM, using the Windows $10$ Pro version $2004$ operating system. \par

%! Software/tools usati
The solver used for obtaining the solutions of the continuous relaxations is CPLEX version $12$.$10$.$0$ with an academic license \cite{cplex}. Its interactive optimizer is also used for presolving problems and writing them to \texttt{mps} files.
The Dirent C API \cite{dirent} is used for easily scanning the instance files to read in the test folder.
The Gnuplot \cite{gnuplot} graphing utility is used to programmatically create the charts presented in this thesis using pipes to pass commands and data points to it directly from the main program.
The R language \cite{rlang} is used to easily manipulate the test results and compute the aggregate measures of interest.

\subsection{Test-bed collection}

%! Testbed: MIPLIBS + tipologie di istanze rimosse + numero istanze testate
The test-bed used for the experiments comprises the instances from the MIPLIB 2003 \cite{miplib2003}, MIPLIB 2010 \cite{miplib2010} and MIPLIB 2017 \cite{miplib2017} problem collections, from which the instances that are incompatible with ZI-Round are removed.
The removed instances include: instances that are infeasible or unbounded, instances that have ranged constraints, instances that have semi-integer or semi-continuous variables according to the terminology used by CPLEX, and instances for which CPLEX is unable to solve the continuous relaxation or exceeds a set time limit of $300$ seconds. To simplify the detection of removable instances, a single run in which only the continuous relaxations are solved is performed: the function \texttt{CPXgetstat} of the CPLEX C API is used to get the solution status and the instances that do not have the status \texttt{CPX\_STAT\_OPTIMAL} are removed from the test-bed. After this pre-processing run, the test-bed obtained contains $1102$ instances.
To virtually increase the size of the test-bed and at the same time test the effect of the performance variability on the end results, the experiments are done using three random seeds. So the actual independent instances are instance-seed pairs, bringing the test-bed size to $3306$. \par 

%! Idea: vedere come cambia la performance lavorando nello spazio dei problemi presolved  creazione di un test-bed presolved usando l’interactive optimizer di CPLEX (breve descrizione), poi gli stessi test sono fatti su questo secondo test-bed
An interesting observation about the way in which CPLEX operates gives rise to an alternative test-bed that can easily be derived from the original one previously described.
When CPLEX solves the continuous relaxation of a problem instance, it applies a presolving process that skims through the problem at hand and reduces it to a different dimensional space in terms of number of variables and/or constraints, usually with a more compact matrix that can make the problem more easily solvable. However, after finding a solution for the modified problem, it converts it back to the original problem space and returns it. This behavior led the supervisor of this thesis D. Salvagnin to suggest performing a second set of experiments on the presolved version of the test-bed, exploiting the more compact formulations of the problems in the hope that ZI-Round could perform differently on the presolved test-bed. The interactive optimizer of CPLEX is used for the test-bed conversion: each instance file in \texttt{mps} format is read, the problem is presolved, written back in \texttt{pre} format, then read again and finally written back in \texttt{mps} format. This conversion process can be automated easily with a simple script, since the interactive optimizer of CPLEX is command line driven and accepts sequences of command strings in input. As done for the original one, the presolved test-bed undergoes the same pre-processing run that filters the instances by the continuous relaxation solution status, leading to the removal of $10$ more instances. So the presolved test-bed has a size of $1092$, which is increased to $3276$ by the use of the three random seeds. \par

%! modalità di test (test_folder), reporting dei risultati (file csv perché sono facilmente manipolabili)
The runs for the experiments on the test-bed folder rely on the Dirent C API to scan the instance files in a way that is easy to code. When each instance has been processed, its related measures are appended to a \texttt{csv} file that holds the test results. The choice of using \texttt{csv} files follows from the ease of processing that software tools as the R language provide for this file extension.

\subsection{Performance and aggregate measures}

%! Misure riportate nei csv
The actual data reported in the test results files comprises: the name of the instance, the random seed used, the final solution cost, the final solution fractionality, the number of rounds performed by ZI-Round, the execution time taken by CPLEX to solve the continuous relaxation, the execution time of ZI-Round, the sum of the two times, and the gap of the solution found with respect to the optimal or best solution available for the given problem. \par 

%! Performance measures (misure aggregate) + come sono calcolate, specificando che sono state calcolate usando scripting in R
In order to evaluate the performance of ZI-Round on the test-beds, the following aggregate measures are computed by means of a script in the R language that processes the files of the test results and of the optimal or best objective values of the instances. \par
The first aggregate measure is the success rate, which evaluates the number of integer solutions found by ZI-Round as a percentage and is computed as the ratio between the number of instances whose solution has a zero fractionality and the total number of instances. \par
The quality of the solutions found by ZI-Round is evaluated by the gap with respect to the optimal or the best solution available, which is computed as a percentage. When an optimal objective value is available, the gap is $0$\% if the optimal solution is found and $100$\% if the objective value is more than twice the optimal one. In case the optimal objective value is zero, the gap can only be either $0$\% for the optimal value or $100$\% for any other value found by ZI-Round. When an optimal objective value is not available but the best one found so far is, the gap is $0$\% if the value found by ZI-Round is less than or equal to it, and $100$\% otherwise. When no solutions have ever been found for the problem, thus no best objective value is available, the gap is $0$\% if any solution is even found and $100$\% otherwise. Programmatically, the script first computes the gap for each tested instance and adds the gap column to the test results file; then computes the average gap, which is the aggregate measure for the test-bed. \par
To evaluate the performance of ZI-Round in terms of execution time, two phases are taken into account: the phase in which CPLEX solves the continuous relaxation to produce the input initial solution for ZI-Round and the actual execution of the heuristic. Execution times are measured by means of calls to the functions \texttt{QueryPerformanceCounter} and \texttt{QueryPerformanceFrequency}, included in the \texttt{windows.h} header file, and are expressed in milliseconds. The aggregate measure involving execution times used to convey information about the performance of ZI-Round on the whole test-bed is the shifted geometric mean (SGM). 
For a sequence of measured execution times $\{t_i\}_{i=1}^{n}$ and a shift $s$, the SGM is given by:
\begin{equation}
	\sqrt[n]{\prod_{i=1}^{n}(t_i+s)} - s = e^{\dfrac{\sum_{i=1}^{n}(t_i+s)}{n}}-s
\end{equation}
%! Perchè usare la media geometrica shiftata
The geometric mean is used in its shifted version to avoid giving the same relevancy, for example, to an improvement from $20$ to $10$ milliseconds and an improvement from $2000$ to $1000$ milliseconds.
The shifts used for the SGM of the continuous relaxation and ZI-Round execution times are of $1000$ and $10$ milliseconds, respectively.
A composite aggregate measure that is derived from the SGMs of the two execution times is the ratio between the SGM of the ZI-Round and continuous relaxation execution times, expressed as a percentage, which gives an idea of the fraction of time used by ZI-Round with respect to the time taken to solve the continuous relaxation of the problem.

\section{Experimental results} \label{sec:expresults}

\nocite{*}
\renewcommand{\bibname}{References}
\begin{thebibliography}{9}
	
	\bibitem{wallace2010} C. Wallace, \textit{ZI round, a MIP rounding heuristic}. Journal of Heuristics, vol. 16, pp. 715–722 (2010). \\ DOI: \url{https://doi.org/10.1007/s10732-009-9114-6}

	\bibitem{linker1973} S. Lin, B. W. Kernighan, \textit{An Effective Heuristic Algorithm for the Traveling-Salesman Problem}. Operations Research, vol. 21, no. 2, pp. 498-516, INFORMS (1973). \\ DOI: \url{https://doi.org/10.1287/opre.21.2.498}
	
	% \newpage
	\vspace{0.5cm}
	%* SITOGRAPHY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\textsc{\Large \textbf{Sitography}}
	%*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\bibitem{cplex} IBM ILOG CPLEX Optimization Studio. \\ URL: \url{https://www.ibm.com/products/ilog-cplex-optimization-studio} \\ (last visited: )

	\bibitem{scip} SCIP MIP solver (non-commercial). \\ URL: \url{https://www.scipopt.org/} \\ (last visited: )

	\bibitem{dirent} Dirent C API. \\ URL: \url{https://github.com/tronkko/dirent} \\ (last visited: )

	\bibitem{gnuplot} Gnuplot graphing utility. \\ URL: \url{http://www.gnuplot.info/} \\ (last visited: )

	\bibitem{rlang} R project. \\ URL: \url{https://www.r-project.org/} \\ (last visited: )

	\bibitem{miplib2003} MIPLIB 2003. \\ URL: \url{http://miplib2010.zib.de/miplib2003/} \\ (last visited: )

	\bibitem{miplib2010} MIPLIB 2010. \\ URL: \url{http://miplib2010.zib.de/} \\ (last visited: )

	\bibitem{miplib2017} MIPLIB 2017. \\ URL: \url{http://miplib.zib.de/} \\ (last visited: )
	
\end{thebibliography}

\end{document}