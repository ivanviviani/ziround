https://unipd.zoom.us/j/6314983243

X Cambia parametri funzioni util -> togli instance -> specifici
X Sostituisci condizioni possibili con gli assert compatibili
X Aggiusta comportamento bufind circolare per includere anche stampa per cambiamenti di objval e #rounded
X Update incrementale del numero di variabili rounded
X Implementa test automatico di una cartella intera
X Update incrementale della solution fractionality
X Update incrementale dei valori dei singletons slack (dovrebbe bastare sommare i delta_ss)
X Debug e test su tutta la miplib2003 (no ranged constraints)
X Calcolare e stampare la statistica #esecuzioni del ciclo esterno (passate di quello interno)
X All'inizio ordinare i singleton per loro coefficiente nella funzione obiettivo
X Controllare che i valori finali di objval e solfrac corrispondano a quelli calcolati direttamente sulla soluzione finale
X Scrivere pseudocodice di ZI-Round mia versione + spiegazione a parole mie il più chiara e completa possibile, chiarendo i criteri di arrotondamento e dove vengono usati
X Controllare che dopo aver ordinato i singletons i loro bounds corrispondano (dovrebbero per merito del singleton_index)
X Cambiare l'estensione verso un default attiva e con flag opzionale settare "disattiva uso dei singletons"
X Aggiungere l'ultima combinazione di plot (solcost + vars to round)
X Mettere come opzionale l'estensione che shifta le variabili intere di 1.0 migliorando objval
X Nel codice, aggiustare la misurazione del tempo di esecuzione dell'algoritmo ZI-Round in se e separatamente della risoluzione del LP (stabilendo una deviazione standard di errore sui millisecondi misurati). -> errore 14 millisecondi
X Rifare il test per std misurazione tempi ripetendo 1000 volte la risoluzione della stessa istanza campione arbitraria (es. fast0507) -> errore 14 millisecondi
X Impostare il timelimit di default a 5/10 minuti (necessario per risolvere gli lp)
X Aggiungere il supporto nel codice e stampa dei dati con aggiunta di (seed) dopo nome istanza
X [IMPORTANTE] Escludere dalle 3 miplib le istanze con vincoli RANGED (X) e quelle con variabili SEMIINT/SEMICONT (X)
X Script R: preparare la stampa delle misure aggregate sul test-bed (usa miplib2003 per debug)

?? Scegliere 3/5 semi random per espandere il test-bed ulteriormente --> random seeds: 0 , 1206151 , 37029
?? Nel codice, aggiungere l'opzione settabile di attivare lo shifting di 1 delle variabili già rounded dopo che la fractionality della soluzione raggiunge zero: occhio che quando sono rounded ho già una soluzione feasible in mano
?? Nel codice, aggiungere i'opzione di scegliere quante passate delle variabili fare (da 1 in su): raggiunto il limite uscire dal ciclo esterno e ritornare la soluzione corrente

?? Preparare il testbed: MIPLIB 2003 + 2010 + 2017 (senza duplicati) e RIMUOVERE le istanze con vincoli RANGED e quelle INFEASIBLE e quelle UNBOUNDED (per quelle per cui una soluzione ottima non è consciuta ("unkn") vedi mail salvagnin -> gap 0% o 100%)
?? Una volta creato il test-bed definitivo, creare un file di testo con l'elenco delle istanze usate
?? Fare i test sul test-bed definitivo


?? Pensare se per ordinare i singletons occorre considerare anche i loro upper/lower bounds (nel senso capacità di variare objval)

OBSERVATIONS:
?? Alcune iterazioni del ciclo interno azzerano la solfrac e trovano un costo minore, poi l'iter successiva cambia altre variabili lasciando la solfrac a zero ma il costo aumenta. Quindi non viene trovato il minimo valore di objval.